/*
*关于C语言指针的学习
 */

/*
1.我们需要一个整型的指针（int*）来映射一个整型变量的地址，同理还有char，float，double，结构体或自定义型指针。
原因在于每个变量类型大小不同；表达方式也不同，如浮点数必须满足ieee754规则。
2.指针的两种初始化：int *p=&a / int*p=NULL，指针必须初始化才能使用！
3.指针的两个运算符：&称为引用运算符，*称为解引用运算符
4.不同指针可以强制转换，转换后地址一样（一般都是4字节无损失），但解引用的值不同。
5.三级指针解引用1次为二级指针的值，解引用2次为一级指针的值，解引用3次为变量的值。二级指针同理。
6.malloc函数使用后，使用free函数回收内存，实际上是清理指针数组里的堆空间地址。（以一级指针数组为例）。
7.指针数组，形如 int* p = arr数组。p传递的是arr的基地址， int* p之前打印地址格式为：&arr[i]或(arr+i); 打印值格式为： *(arr+i)或arr[i] ,int* p之后用p表示以上。
8.C语言里面的字符串必须（默认）以NULL或'\o'结束；字符指针会变化，如：指针p++后，指的是下一个字符的地址。


指针和字符数组 (下) P9 - 09:01 存放位置字符数组分配在栈上，所以可以修改；常量指针和常量字符串分配在常量区（属于代码区），不可修改。

1.二维数组传值的格式为：int （*A） [3]或int A[ ][3] ，三维数组传值的格式为：int （*A ）[2][2]或int A[ ][2] [2] （当然还有其他方式）。
2.如果是int*p = malloc(3),类似于我们向堆要了3个整型的数组，*p可以写成p[0],*(p+1)可以写成p[1], 他们的含义是一样的。记住：动态内存的操作都是基于基地址的指针！
3.int* p =(int*)malloc(sizeof(int)); 不过最新的vs2023好像会自动强制转换，所以写成 int* p=malloc(sizeof(int)); 也可以！
4.calloc函数和malloc函数区别：1.格式问题calloc（参数个数，参数类型大小）。2.calloc分配完内存会对其初始化。
5.realloc函数主要用于修改分配内存的大小，若分配的原地址后面还有扩展空间就近扩展，没有就复制数据到新的空间。格式为：realloc（原内存起始地址/指针，新内存字节大小）。
6.C和C++的内存泄漏指的是在堆上增长的垃圾，总是由于堆中未使用和未引用的内存块才发生的。栈上的内存是固定的，但是有回收机制，避免出现栈溢出！
7.什么时候我们需要函数返回一个指针？ 任何时候被调函数执行时，主调函数仍然在栈内存中。
但当被调函数结束控制返回主调函数时，那块栈内存早已被释放了，后续再使用原栈内存时很可能非原值。
因此从栈顶向下传/返回一个局部变量或其地址是不可靠的。
函数返回一个指针的用处：多数时候返回堆上分配内存的地址，或是全局区的内存地址，这些内存的值只在程序结束时才改变。
8.关于函数指针：基本上一个函数就是一组指令用来执行一个子任务，函数指针就是该函数在内存里的第一条指令地址，存在代码区。
注意函数指针中声明的类型要和所指这个函数类型一致，函数指针声明的格式：int(*p) (int,int) 或void (*p)(char*)或 int(*p) ( ) ，
函数指针调用的格式：p = Add ; int c = *p(2, 3) / c = p(2, 3)
9.函数指针作函数的参数时为函数地址传递，一般利用返回值控制主调函数，应用之一为“事件处理”。
 */

//指针的基本介绍
//要理解指针，首先需要了解不同的数据类型或者不同的变量吗，在计算机中是如何存储的 。
//在一个典型的计算机内存系统中，每一个字节都有一个地址
//指针是一个变量，他存放着另一变量的地址。

//实际的指针代码实例

#include <stdio.h>
#include <inttypes.h>  // 包含 PRIuPTR 定义

int main() {
	int a = 10;
	int *p = &a;//现在P是一个指针变量，换句话说P是一个存放整形变量的地址的变量。

	// 正确打印十进制地址
	printf("%lu\n", (uintptr_t)p);   // p的值（&a的地址）
	printf("%lu\n", (uintptr_t)&a);  // a的地址
	printf("%lu\n", (uintptr_t)&p);  // p自身的地址

	// 打印指针指向的值（正确方式）
	printf("%d\n", *p);  // 输出a的值（10）

	*p= 15;//解引用
	printf("%d\n",*p);

	//指针的算术运算
	printf("%lu\n",(uintptr_t)p);//假设地址为2002
	printf("%d\n",*p);
	printf("%lu\n",(uintptr_t)(p+1));//int类型的指针+1后，2002+4=2006.
	printf("%d\n",*(p+1));//垃圾值，这是使用指针运算时的一个危险地方。利用指针操作可以到达任何地方，有时候这种操作会引起不期望的行为。
	return 0;
}

/*
不推荐直接使用 %d 打印指针地址，因为这会导致未定义行为或错误结果。原因如下：
为什么不能用 %d 直接打印指

类型不匹配：
%d 用于 int 类型（通常4字节）
指针在32位系统是4字节，但在64位系统是8字节
直接传递指针给 %d 会读取错误大小的内存

截断风险：
在64位系统上，地址高4字节会被丢弃
示例：地址 0x7ffeebd0a9dc 会被截断为 0xebd0a9dc

未定义行为：(待学习)
C标准规定类型不匹配的 printf 会导致未定义行为
可能导致程序崩溃、输出乱码或错误值
*/

//指针的类型，空的指针（void pointer）,指针的算数运算
