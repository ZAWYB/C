/*
 *关于C语言指针的学习
 */

/*
1.我们需要一个整型的指针（int*）来映射一个整型变量的地址，同理还有char，float，double，结构体或自定义型指针。
原因在于每个变量类型大小不同；表达方式也不同，如浮点数必须满足ieee754规则。
2.指针的两种初始化：int *p=&a / int*p=NULL，指针必须初始化才能使用！
3.指针的两个运算符：&称为引用运算符，*称为解引用运算符
4.不同指针可以强制转换，转换后地址一样（一般都是4字节无损失），但解引用的值不同。
5.三级指针解引用1次为二级指针的值，解引用2次为一级指针的值，解引用3次为变量的值。二级指针同理。
6.malloc函数使用后，使用free函数回收内存，实际上是清理指针数组里的堆空间地址。（以一级指针数组为例）。
7.指针数组，形如 int* p = arr数组。p传递的是arr的基地址， int* p之前打印地址格式为：&arr[i]或(arr+i); 打印值格式为： *(arr+i)或arr[i] ,int* p之后用p表示以上。
8.C语言里面的字符串必须（默认）以NULL或'\o'结束；字符指针会变化，如：指针p++后，指的是下一个字符的地址。


指针和字符数组 (下) P9 - 09:01 存放位置字符数组分配在栈上，所以可以修改；常量指针和常量字符串分配在常量区（属于代码区），不可修改。

1.二维数组传值的格式为：int （*A） [3]或int A[ ][3] ，三维数组传值的格式为：int （*A ）[2][2]或int A[ ][2] [2] （当然还有其他方式）。
2.如果是int*p = malloc(3),类似于我们向堆要了3个整型的数组，*p可以写成p[0],*(p+1)可以写成p[1], 他们的含义是一样的。记住：动态内存的操作都是基于基地址的指针！
3.int* p =(int*)malloc(sizeof(int)); 不过最新的vs2023好像会自动强制转换，所以写成 int* p=malloc(sizeof(int)); 也可以！
4.calloc函数和malloc函数区别：1.格式问题calloc（参数个数，参数类型大小）。2.calloc分配完内存会对其初始化。
5.realloc函数主要用于修改分配内存的大小，若分配的原地址后面还有扩展空间就近扩展，没有就复制数据到新的空间。格式为：realloc（原内存起始地址/指针，新内存字节大小）。
6.C和C++的内存泄漏指的是在堆上增长的垃圾，总是由于堆中未使用和未引用的内存块才发生的。栈上的内存是固定的，但是有回收机制，避免出现栈溢出！
7.什么时候我们需要函数返回一个指针？ 任何时候被调函数执行时，主调函数仍然在栈内存中。
但当被调函数结束控制返回主调函数时，那块栈内存早已被释放了，后续再使用原栈内存时很可能非原值。
因此从栈顶向下传/返回一个局部变量或其地址是不可靠的。
函数返回一个指针的用处：多数时候返回堆上分配内存的地址，或是全局区的内存地址，这些内存的值只在程序结束时才改变。
8.关于函数指针：基本上一个函数就是一组指令用来执行一个子任务，函数指针就是该函数在内存里的第一条指令地址，存在代码区。
注意函数指针中声明的类型要和所指这个函数类型一致，函数指针声明的格式：int(*p) (int,int) 或void (*p)(char*)或 int(*p) ( ) ，
函数指针调用的格式：p = Add ; int c = *p(2, 3) / c = p(2, 3)
9.函数指针作函数的参数时为函数地址传递，一般利用返回值控制主调函数，应用之一为“事件处理”。
 */